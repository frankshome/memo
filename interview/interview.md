[toc]

# Interview

## Java

### 1. 基础

#### 1.1. 什么是内存泄漏？什么是内存溢出？

没有及时回收无用的对象是内存泄漏；创建了太多的对象，导致内存空间不足是内存溢出。

### 2. JVM 

#### 2.1. JVM内存结构

![JVM内存结构](images/JVM内存结构.PNG)

##### 2.1.1. 程序计数器

在Java中每个线程都有一个程序计数器，每个线程每一时刻只有一个方法在运行，程序计数器用于记录当前运行方法的JVM指令地址。如果是本地方法则是undefined。

##### 2.2.2. Java虚拟机栈

每个线程在创建的时候都会有一个虚拟机栈，每个栈中保存着一个个栈桢，虚拟机对栈的操作就是`入栈`和`出栈`。

栈桢中存放着`局部变量表` `操作数栈` `动态链接` `方法正常退出` 或 `异常退出的定义等`

##### 2.2.3. 堆

Java中几乎所有对象实例都放置在堆中，堆是垃圾回收主要照顾的区域

> Hotspot虚拟机并没有把不会逃逸的对象分配在栈上，在1.8的Hotspot中，字符串常量池从永久代移到了堆上，所以对于Hotspot来说，所有的对象都分配在堆上。

JIT优化中的逃逸分析，使得变量直接分配在栈上。当对象或者是变量在方法中创建之后，这个对象的指针会被线程所引用，这个对象就被称之为`引用逃逸`或`指针逃逸`

对象逃逸的代码如下：

```java
public static StringBuffer getBuff() {
    StringBuffer buff = new StringBuffer("hello world!");
    return buff;
}
```

buff虽然是一个局部变量，但是被return出去了，可能会被其他变量所引用和更改，所以buff就算是逃到了方法的外部。

##### 2.2.2.4. 方法区

方法区是所有线程共享的区域，主要存储`类的结构信息` 、`运行时的常量池`、`字段`、`方法代码`等

> PS:方法区是JVM的规范，Oracle的HotSpot在1.7的实现较永久代，1.8叫元数据区



#### 2.2. 垃圾回收的算法有哪些？

垃圾回回收器首先要做的事情就是判断对象的`存活状态`，死亡的对象会被标注为垃圾数据，等待收集器清除。

##### 2.2.1 判断一个对象存活状态的常用算法有？

- 引用计数法(Reference Counting)

  > 创建对象时，关联一个与之相对的计数器，对象被使用时+1，被销毁时-1，为0时表示对象未被使用，可以回收。`优点`是回收效率高，`缺点`是无法解决循环引用的问题。

- 可达性分析法(Reachability Analysis)

  > 可达性分析算法是目前商业系统中使用比较多的算法，它是指从GC Roots起点开始向下搜索，GC Roots和对象之间没有任何引用链关联的时候即GC Roots不可达，表示该对象可被回收。



确定了对象的存活状态后，就可以进行垃圾回收了，垃圾回收的主要算法有:

##### 2.2.2 标记-清除算法

##### 2.2.3 标记-复制算法

##### 2.2.4 标记整理算法



#### 2.3. GC ROOT有哪些？

- 虚拟机栈中正在引用的对象
- 本地方法栈中正在引用的对象
- 静态属性引用的对象和常量

#### 3. 常见的哪集回收器有哪些？

#### 4. 为什么需要Stop-The-World

#### 5. 逃逸分析







#### 2. JVM内存模型(JMM)



## 数据库



## 中间件



## 分布式



## 生产事故



## 自我介绍

