[toc]

# Interview

## Java

### 1. 基础

#### 1.1. 什么是内存泄漏？什么是内存溢出？

没有回收无用的对象是内存泄漏；创建了太多的对象，导致内存空间不足是内存溢出。

#### 1.2. HashMap的源码？为什么要有加载因子？说一下HashMap的底层结构。

看过HashMap的源码，底层结构是由`数组`+`链表`构成，JDK8以后新增了`红黑树`

- 加载因子的作用主要是因为尽量留有足够的空闲位置，减少Hash碰撞的情况，以便提高检索效率。
- 链表长度大于8且数组长度大于64，链表会变成红黑树；
- 红黑树的节点数小于6会退化为红黑树；

#### 1.3. 为什么链表的长度是8才转换红黑树？为什么要使用红黑树？

- 8是根据`泊松分布`概率统计来的，hash碰撞冲突的概率，8的话概率低于千万分之一；
- 因为链表的遍历的时间复杂度为O(n)，普通的二叉搜索树在极端情况下，会退化为线性情况(所有数据都在根节点的一侧)，时间复杂度不稳定，而红黑树因为有自平衡，能够保证查询的效率始终是O(log n)
- 知识点`二叉搜索树`、`红黑树`、`AVL树`、`跳表`

#### 1.4 HashMap为什么不是线程安全的，JDK8之前有什么问题？

JDK中明确说明了HashMap是非线程安全的。JDK8之前rehash的过程中会出现循环引用，在get时会出现死循环。

JDK1.8后resize时不再rehash，直接利用高位判断计算心得位置，且在链表后直接追加，而不是如同1.7一样追加在链表的前面。



### 2. JVM 

#### 2.1. JVM内存结构

![JVM内存结构](images/JVM内存结构.PNG)

##### 2.1.1. 程序计数器

在Java中每个线程都有一个程序计数器，每个线程每一时刻只有一个方法在运行，程序计数器用于记录当前运行方法的JVM指令地址。如果是本地方法则是undefined。

##### 2.2.2. Java虚拟机栈

每个线程在创建的时候都会有一个虚拟机栈，每个栈中保存着一个个栈桢，虚拟机对栈的操作就是`入栈`和`出栈`。

栈桢中存放着`局部变量表` `操作数栈` `动态链接` `方法正常退出` 或 `异常退出的定义等`

##### 2.2.3. 堆

Java中几乎所有对象实例都放置在堆中，堆是垃圾回收主要照顾的区域

> Hotspot虚拟机并没有把不会逃逸的对象分配在栈上，在1.8的Hotspot中，字符串常量池从永久代移到了堆上，所以对于Hotspot来说，所有的对象都分配在堆上。

JIT优化中的逃逸分析，使得变量直接分配在栈上。当对象或者是变量在方法中创建之后，这个对象的指针会被线程所引用，这个对象就被称之为`引用逃逸`或`指针逃逸`

对象逃逸的代码如下：

```java
public static StringBuffer getBuff() {
    StringBuffer buff = new StringBuffer("hello world!");
    return buff;
}
```

buff虽然是一个局部变量，但是被return出去了，可能会被其他变量所引用和更改，所以buff就算是逃到了方法的外部。

##### 2.2.2.4. 方法区

方法区是所有线程共享的区域，主要存储`类的结构信息` 、`运行时的常量池`、`字段`、`方法代码`等

> PS:方法区是JVM的规范，Oracle的HotSpot在1.7的实现较永久代，1.8叫元数据区



#### 2.2. 垃圾回收的算法有哪些？

垃圾回回收器首先要做的事情就是判断对象的`存活状态`，死亡的对象会被标注为垃圾数据，等待收集器清除。

##### 2.2.1 判断一个对象存活状态的常用算法有？

- 引用计数法(Reference Counting)

  > 创建对象时，关联一个与之相对的计数器，对象被使用时+1，被销毁时-1，为0时表示对象未被使用，可以回收。`优点`是回收效率高，`缺点`是无法解决循环引用的问题。

- 可达性分析法(Reachability Analysis)

  > 可达性分析算法是目前商业系统中使用比较多的算法，它是指从GC Roots起点开始向下搜索，GC Roots和对象之间没有任何引用链关联的时候即GC Roots不可达，表示该对象可被回收。



确定了对象的存活状态后，就可以进行垃圾回收了，垃圾回收的主要算法有:

##### 2.2.2 标记-清除算法(Mark-Sweep)

`标记-清除算法` 由`标记阶段`和`清除阶段`构成，`标记阶段`主要是标记存活的对象，`清除阶段`主要是将未标记存活的对象回收。而标记的判断就是依据前面的`引用计数法`和`可达性分析算法`

> 标记-清除算法一个最大的问题就是 `内存空间碎片化`，标记清除算法完成后，会产生大量的不连续的内存空间。加入程序这时候需要分配一个大对象时，因为没有足够的连续空间，会提前触发垃圾回收。

##### 2.2.3 标记-复制算法(Mark-Copy)

`标记-清除算法`是将内存空间分为大小相等的两块区域，每次只使用其中一块区域，进行垃圾回收时将`存活`的对象复制到新的内存区域上，再把旧的全部清除掉。

> 与`标记-清除算法`比较，`标记-复制算法`算是一个升级算法，解决了内存碎片化的问题，但是引入了一个新的问题，由于内存区域被分成了两块相同的区域，每次只使用其中一块，使得`内存的利用率`降低了。

##### 2.2.4 标记-整理算法(Mark-Compact)

`标记-整理算法`的诞生晚于以上两个算法，也是分两个阶段构成，其中`标记`阶段同之前一样，主要是`整理阶段`会将存活的对象，向一端移动，然后把另一端的死亡对象全部清除掉。

#### 2.3. GC Roots有哪些？

- 虚拟机栈中正在引用的对象
- 本地方法栈中正在引用的对象
- 静态属性引用的对象和常量

#### 2.4. Java常见的垃圾收集器有哪些？

实际上不同的JVM，提供的垃圾收集器的选择也不尽相同。下面基于最主流的Oracle JDK谈一谈

- Serial GC

  > 最古老的`串行`垃圾收集器，在进行垃圾回收的过程中，会进入臭名昭著的`STW`状态，其好处就是设置精简，无需维护复杂的数据结构，是Client默认垃圾收集器。
  >
  > 新生代的Serial GC使用的是`标记-复制算法`
  >
  > 在老年代中被称作单独的Serial Old, 使用的是`标记-整理算法`
  >
  > 对应的JVM参数:`-XX:+UseSerialGC`

- ParNew GC

  > ParNew GC 是一个新生代的GC算法，是Serial GC的多线程版本，主要是为了配合 CMS GC做新生代的垃圾回收工作。
  >
  > 对应的JVM参数：`-XX:+UseConcurrentMarkSweepGC` `-XX:+UseParNewGC` 

- CMS (Concurrent Mark Sweep)

  > 基于`标记-清除算法`设计的目标是尽量减少GC停顿时间。因为采用`标记-清除`算法，长时间运行不可避免的会产生内存碎片化的问题，所以会触发Full GC。在JDK9中已经被标注废弃

- Parallel GC

  > 是早起Java8中Server端默认的GC收集器，被称作吞吐量优先的GC，算法和Serial GC类似，特点是 新生代和老年代GC都是并行进行的。
  >
  > JVM的参数是: `-XX:+UseParallelGC`另外还可以设置停顿时间`-XX:MaxPauseGCMillis=value`，吞吐量`-XX:GCTimeRatio=N // GC时间和用户时间的比例 = 1/(N+1)`

- G1 GC

  > G1 是 JDK9 默认的垃圾收集器，其将内存空间分成一个个region，每个region默认16M，region和region之间采用的是`标记-复制`算法，整体可以看做是`标记-整理`算法，所以避免了碎片化的问题，更适用于大内存。

- ZGC

  > JDK11新增的支持T bytes级别的堆大小，保证绝大多数场景延迟不会超过10ms。

#### 4. 为什么需要Stop-The-World

> 为了增加对象标记的准确性，比如A B两个对象，B对象在执行标记阶段，未被标记存活，但同时用户线程中的A对象使用了B对象，会导致B对象被误清除。

#### 5. 逃逸分析



#### 6. JVM内存模型(JMM)



## 数据库



## 中间件



## 分布式



## 生产事故



## 自我介绍



## 数据结构与算法

### 树

#### 二叉搜索树

#### 红黑树

#### AVL树

#### B+树





### 跳表

